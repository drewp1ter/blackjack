# карточная колода в данном классе представлена в виде массива бит
# рассмотрим логику работы на примере из 16 карт
# 0b1111_1111_1111_1111
#   ^тузы     ^дамы ^вальты и т.д. чем младше бит - тем меньше карта, на каждый ранг 4 таких еденички - масти
# например 0b0001_0000_0000_0000 - туз треф или 0b0000_0100_0000_1000 - король червей и валет бубей
# удалить карту из колоды: 
# 0b1111_1111_1111_1111
# -
# 0b0001_0000_0000_0000 - туз треф
# =
# 0b1110_1111_1111_1111 - тут уже нет туза
# проверить, есть ли карта в колоде:
# 0b1111_0001_1111_1111        или 0b1111_0101_1111_1111
# &                                &
# 0b0000_0100_0000_0000            0b0000_1111_0000_0000 - "достать" только королей
# =                                =
# 0b0000_0000_0000_0000 - нема     0b0000_0101_0000_0000 - есть треф и червей
# добавлять карты в колоду элементарно: сложением или через логический оператор |

class Deck    # brain fuck 
  
  class << self
    #подсчет очков
    def score(deck)
      quad_index = 2 # порядковый номер значения карт, т.е. 2-ки, 3-ки, ..., 13 - короли, 14 -тузы
      score = 0 #сумма всех очков
      while deck > 0 # считаем пока не закончиться "пачка" карт
        quad = deck & 0b1111 #берем с конца колоды 4 карты одного ранга
        while quad > 0 #перебираем и считаем карты текущего ранга, если они есть или пока не закончаться все масти  
          score += quad_index < 10 ? quad_index : quad_index == 14 ? 
            (score + 11) - 21 > 0 ? 1 : 11 : 10 if quad & 1 == 1 #масть обнаружена - прибавляем
            #((score + 11) - 21).abs < ((score + 1) - 21).abs ? 11 : 1 : 10 if quad & 1 == 1 #масть обнаружена - прибавляем         
          quad >>= 1 #следующая масть
        end
        quad_index += 1
        deck >>= 4 #двигаем биты вправо - следующие 4 карты на подсчет  
      end
      score
    end

    def to_s(deck)
      kinds = [*'2'..'10', 'J', 'Q', 'K', 'A']
      rezult = ''
      quad_index = 0
      while deck > 0
        suits = 0x2663 #треф юникод
        quad = deck & 0b1111
        while quad > 0  
          rezult += "|#{kinds[quad_index] + suits.chr('UTF-8')}| " if quad & 1 == 1
          suits += 1
         quad >>= 1
        end
        quad_index += 1    
        deck >>= 4
      end
      rezult
    end
    
    def count(deck)
      k = 0
      while deck > 0 
        k += 1 if deck & 1 == 1
        deck >>= 1
      end
      k
    end
    
  end
  
  def initialize
    @deck = 0xFFFFFFFFFFFFF #заполняем колоду, т.е. в бинарном виде это 52 еденички
  end
  # генерируем карту сдвигая бит влево (по сути это степени 2-ки), 
  # если сгенерированная карта есть в колоде - отдаем, если нет - генерируем снова
  def take_card
    raise "Deck is empty!" if @deck == 0
    card = 0
    card = 1 << rand(52) while @deck & card == 0 
    @deck -= card
    card
  end
  
end